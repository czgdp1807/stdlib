#:include "common.fypp"
#:set RANKS = range(1, MAXRANK + 1)
#:set REDRANKS = range(2, MAXRANK + 1)
#:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
#:set IR_KINDS_TYPES_OUTPUT = list(zip(INT_KINDS,INT_TYPES, ['dp']*len(INT_KINDS))) + list(zip(REAL_KINDS, REAL_TYPES, REAL_KINDS))
module stdlib_stats
  !! Provides support for various statistical methods. This includes currently
  !! descriptive statistics
  !! ([Specification](../page/specs/stdlib_stats.html))
  use stdlib_kinds, only: sp, dp, xdp, qp, &
      int8, int16, int32, int64
  use, intrinsic:: ieee_arithmetic, only: ieee_value, ieee_quiet_nan
  use stdlib_error, only: error_stop
  use stdlib_linalg, only: diag
  use stdlib_optval, only: optval
  implicit none
  private
  ! Public API
  public :: corr, cov, mean, median, moment, var


  interface corr
    !! version: experimental
    !!
    !! Pearson correlation of array elements
    !! ([Specification](../page/specs/stdlib_stats.html#corr-pearson-correlation-of-array-elements))
    #:for k1, t1 in RC_KINDS_TYPES
      #:set RName = rname("corr",1, t1, k1)
      procedure :: ${RName}$
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:set RName = rname("corr",1, t1, k1, 'dp')
      procedure :: ${RName}$
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:set RName = rname("corr_mask",1, t1, k1)
      procedure :: ${RName}$
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:set RName = rname("corr_mask",1, t1, k1, 'dp')
      procedure :: ${RName}$
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:set RName = rname("corr",2, t1, k1)
      procedure :: ${RName}$
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:set RName = rname("corr",2, t1, k1, 'dp')
      procedure :: ${RName}$
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:set RName = rname("corr_mask",2, t1, k1)
      procedure :: ${RName}$
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:set RName = rname("corr_mask",2, t1, k1, 'dp')
      procedure :: ${RName}$
    #:endfor

  end interface corr


  interface cov
    !! version: experimental
    !!
    !! Covariance of array elements
    !! ([Specification](../page/specs/stdlib_stats.html#cov-covariance-of-array-elements))
    #:for k1, t1 in RC_KINDS_TYPES
      #:set RName = rname("cov",1, t1, k1)
      procedure :: ${RName}$
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:set RName = rname("cov",1, t1, k1, 'dp')
      procedure :: ${RName}$
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:set RName = rname("cov_mask",1, t1, k1)
      procedure :: ${RName}$
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:set RName = rname("cov_mask",1, t1, k1, 'dp')
      procedure :: ${RName}$
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:set RName = rname("cov",2, t1, k1)
      procedure :: ${RName}$
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:set RName = rname("cov",2, t1, k1, 'dp')
      procedure :: ${RName}$
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:set RName = rname("cov_mask",2, t1, k1)
      procedure :: ${RName}$
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:set RName = rname("cov_mask",2, t1, k1, 'dp')
      procedure :: ${RName}$
    #:endfor
  end interface cov


  interface mean
    !! version: experimental
    !!
    !! Mean of array elements
    !! ([Specification](../page/specs/stdlib_stats.html#mean-mean-of-array-elements))
    #:for k1, t1 in RC_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("mean_all",rank, t1, k1)
        procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:for rank in RANKS
      #:set RName = rname('mean_all', rank, t1, k1,'dp')
        procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:for rank in RANKS
      #:set RName = rname("mean",rank, t1, k1)
        procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("mean",rank, t1, k1,'dp')
        procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname('mean_mask_all',rank, t1, k1)
        procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:for rank in RANKS
      #:set RName = rname('mean_mask_all',rank, t1, k1, 'dp')
        procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:for rank in RANKS
      #:set RName = rname('mean_mask',rank, t1, k1)
        procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:for rank in RANKS
      #:set RName = rname('mean_mask',rank, t1, k1, 'dp')
        procedure :: ${RName}$
      #:endfor
    #:endfor

  end interface mean


  interface median
    !! version: experimental
    !!
    !! Median of array elements
    !! ([Specification](../page/specs/stdlib_stats.html#median-median-of-array-elements))
    #:for k1, t1, o1 in IR_KINDS_TYPES_OUTPUT
      #:for rank in RANKS
        #:set name = rname("median_all",rank, t1, k1, o1)
        module function ${name}$ (x, mask) result(res)
          ${t1}$, intent(in) :: x${ranksuffix(rank)}$
          logical, intent(in), optional :: mask
          real(${o1}$) :: res
        end function ${name}$
      #:endfor
    #:endfor

    #:for k1, t1, o1 in IR_KINDS_TYPES_OUTPUT
      #:for rank in RANKS
        #:set name = rname("median",rank, t1, k1, o1)
        module function ${name}$(x, dim, mask) result(res)
          ${t1}$, intent(in) :: x${ranksuffix(rank)}$
          integer, intent(in) :: dim
          logical, intent(in), optional :: mask
          real(${o1}$) :: res${reduced_shape('x', rank, 'dim')}$
        end function ${name}$
      #:endfor
    #:endfor

    #:for k1, t1, o1 in IR_KINDS_TYPES_OUTPUT
      #:for rank in RANKS
        #:set name = rname('median_all_mask',rank, t1, k1, o1)
        module function ${name}$(x, mask) result(res)
          ${t1}$, intent(in) :: x${ranksuffix(rank)}$
          logical, intent(in) :: mask${ranksuffix(rank)}$
          real(${o1}$) :: res
        end function ${name}$
      #:endfor
    #:endfor

    #:for k1, t1, o1 in IR_KINDS_TYPES_OUTPUT
      #:for rank in RANKS
        #:set name = rname('median_mask',rank, t1, k1, o1)
        module function  ${name}$(x, dim, mask) result(res)
          ${t1}$, intent(in) :: x${ranksuffix(rank)}$
          integer, intent(in) :: dim
          logical, intent(in) :: mask${ranksuffix(rank)}$
          real(${o1}$) :: res${reduced_shape('x', rank, 'dim')}$
        end function ${name}$
      #:endfor
    #:endfor

  end interface


  interface var
    !! version: experimental
    !!
    !! Variance of array elements
    !! ([Specification](../page/specs/stdlib_stats.html#var-variance-of-array-elements))

    #:for k1, t1 in RC_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("var_all",rank, t1, k1)
          procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("var_all",rank, t1, k1, 'dp')
          procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("var",rank, t1, k1)
          procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("var",rank, t1, k1, 'dp')
          procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("var_mask_all",rank, t1, k1)
          procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("var_mask_all",rank, t1, k1, 'dp')
          procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("var_mask",rank, t1, k1)
          procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("var_mask",rank, t1, k1, 'dp')
          procedure :: ${RName}$
      #:endfor
    #:endfor

  end interface var


  interface moment
    !! version: experimental
    !!
    !! Central moment of array elements
    !! ([Specification](../page/specs/stdlib_stats.html#moment-central-moments-of-array-elements))
    #:for k1, t1 in RC_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("moment_all",rank, t1, k1)
        module function ${RName}$(x, order, center, mask) result(res)
          ${t1}$, intent(in) :: x${ranksuffix(rank)}$
          integer, intent(in) :: order
          ${t1}$, intent(in), optional :: center
          logical, intent(in), optional :: mask
          ${t1}$ :: res
        end function ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("moment_all",rank, t1, k1, 'dp')
        module function ${RName}$(x, order, center, mask) result(res)
          ${t1}$, intent(in) :: x${ranksuffix(rank)}$
          integer, intent(in) :: order
          real(dp), intent(in), optional :: center
          logical, intent(in), optional :: mask
          real(dp) :: res
        end function ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:for rank in REDRANKS
        #:set RName = rname("moment_scalar",rank, t1, k1)
        module function ${RName}$(x, order, dim, center, mask) result(res)
          ${t1}$, intent(in) :: x${ranksuffix(rank)}$
          integer, intent(in) :: order
          integer, intent(in) :: dim
          ${t1}$, intent(in) :: center
          logical, intent(in), optional :: mask
          ${t1}$ :: res${reduced_shape('x', rank, 'dim')}$
        end function ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("moment",rank, t1, k1)
        module function ${RName}$(x, order, dim, center, mask) result(res)
          ${t1}$, intent(in) :: x${ranksuffix(rank)}$
          integer, intent(in) :: order
          integer, intent(in) :: dim
          ${t1}$, intent(in), optional :: center${reduced_shape('x', rank, 'dim')}$
          logical, intent(in), optional :: mask
          ${t1}$ :: res${reduced_shape('x', rank, 'dim')}$
        end function ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:for rank in REDRANKS
        #:set RName = rname("moment_scalar",rank, t1, k1, 'dp')
        module function ${RName}$(x, order, dim, center, mask) result(res)
          ${t1}$, intent(in) :: x${ranksuffix(rank)}$
          integer, intent(in) :: order
          integer, intent(in) :: dim
          real(dp),intent(in) :: center
          logical, intent(in), optional :: mask
          real(dp) :: res${reduced_shape('x', rank, 'dim')}$
        end function ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("moment",rank, t1, k1, 'dp')
        module function ${RName}$(x, order, dim, center, mask) result(res)
          ${t1}$, intent(in) :: x${ranksuffix(rank)}$
          integer, intent(in) :: order
          integer, intent(in) :: dim
          real(dp),intent(in), optional :: center${reduced_shape('x', rank, 'dim')}$
          logical, intent(in), optional :: mask
          real(dp) :: res${reduced_shape('x', rank, 'dim')}$
        end function ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("moment_mask_all",rank, t1, k1)
        module function ${RName}$(x, order, center, mask) result(res)
          ${t1}$, intent(in) :: x${ranksuffix(rank)}$
          integer, intent(in) :: order
          ${t1}$, intent(in), optional :: center
          logical, intent(in) :: mask${ranksuffix(rank)}$
          ${t1}$ :: res
        end function ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("moment_mask_all",rank, t1, k1, 'dp')
        module function ${RName}$(x, order, center, mask) result(res)
          ${t1}$, intent(in) :: x${ranksuffix(rank)}$
          integer, intent(in) :: order
          real(dp),intent(in), optional :: center
          logical, intent(in) :: mask${ranksuffix(rank)}$
          real(dp) :: res
        end function ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:for rank in REDRANKS
        #:set RName = rname("moment_mask_scalar",rank, t1, k1)
        module function ${RName}$(x, order, dim, center, mask) result(res)
          ${t1}$, intent(in) :: x${ranksuffix(rank)}$
          integer, intent(in) :: order
          integer, intent(in) :: dim
          ${t1}$, intent(in) :: center
          logical, intent(in) :: mask${ranksuffix(rank)}$
          ${t1}$ :: res${reduced_shape('x', rank, 'dim')}$
        end function ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("moment_mask",rank, t1, k1)
        module function ${RName}$(x, order, dim, center, mask) result(res)
          ${t1}$, intent(in) :: x${ranksuffix(rank)}$
          integer, intent(in) :: order
          integer, intent(in) :: dim
          ${t1}$, intent(in), optional :: center${reduced_shape('x', rank, 'dim')}$
          logical, intent(in) :: mask${ranksuffix(rank)}$
          ${t1}$ :: res${reduced_shape('x', rank, 'dim')}$
        end function ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:for rank in REDRANKS
        #:set RName = rname("moment_mask_scalar",rank, t1, k1, 'dp')
        module function ${RName}$(x, order, dim, center, mask) result(res)
          ${t1}$, intent(in) :: x${ranksuffix(rank)}$
          integer, intent(in) :: order
          integer, intent(in) :: dim
          real(dp), intent(in) :: center
          logical, intent(in) :: mask${ranksuffix(rank)}$
          real(dp) :: res${reduced_shape('x', rank, 'dim')}$
        end function ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:for rank in RANKS
        #:set RName = rname("moment_mask",rank, t1, k1, 'dp')
        module function ${RName}$(x, order, dim, center, mask) result(res)
          ${t1}$, intent(in) :: x${ranksuffix(rank)}$
          integer, intent(in) :: order
          integer, intent(in) :: dim
          real(dp), intent(in), optional :: center${reduced_shape('x', rank, 'dim')}$
          logical, intent(in) :: mask${ranksuffix(rank)}$
          real(dp) :: res${reduced_shape('x', rank, 'dim')}$
        end function ${RName}$
      #:endfor
    #:endfor
  end interface moment

  contains

  pure function my_merge(val1, val2, mask) result(merged_value)
    integer, intent(in) :: val1, val2
    logical, intent(in) :: mask
    integer :: merged_value

    if (mask) then
      merged_value = val1
    else
      merged_value = val2
    end if

  end function my_merge


  #:for k1, t1 in RC_KINDS_TYPES
    #:set RName = rname("corr",1, t1, k1)
    function ${RName}$(x, dim, mask) result(res)
      ${t1}$, intent(in) :: x(:)
      integer, intent(in) :: dim
      logical, intent(in), optional :: mask
      real(${k1}$) :: res

      if (.not.optval(mask, .true.) .or. size(x) < 2) then
        res = ieee_value(1._${k1}$, ieee_quiet_nan)
        return
      end if

      res = 1

    end function ${RName}$
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:set RName = rname("corr",1, t1, k1, 'dp')
    function ${RName}$(x, dim, mask) result(res)
      ${t1}$, intent(in) :: x(:)
      integer, intent(in) :: dim
      logical, intent(in), optional :: mask
      real(dp) :: res

      if (.not.optval(mask, .true.) .or. size(x) < 2) then
        res = ieee_value(1._dp, ieee_quiet_nan)
        return
      end if

      res = 1

    end function ${RName}$
  #:endfor


  #:for k1, t1 in RC_KINDS_TYPES
    #:set RName = rname("corr_mask",1, t1, k1)
    function ${RName}$(x, dim, mask) result(res)
      ${t1}$, intent(in) :: x(:)
      integer, intent(in) :: dim
      logical, intent(in) :: mask(:)
      real(${k1}$) :: res

      if (count(mask) < 2) then
        res = ieee_value(1._${k1}$, ieee_quiet_nan)
        return
      end if

      res = 1

    end function ${RName}$
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:set RName = rname("corr_mask",1, t1, k1, 'dp')
    function ${RName}$(x, dim, mask) result(res)
      ${t1}$, intent(in) :: x(:)
      integer, intent(in) :: dim
      logical, intent(in) :: mask(:)
      real(dp) :: res

      if (count(mask) < 2) then
        res = ieee_value(1._dp, ieee_quiet_nan)
        return
      end if

      res = 1

    end function ${RName}$
  #:endfor


  #:for k1, t1 in RC_KINDS_TYPES
    #:set RName = rname("corr",2, t1, k1)
    function ${RName}$(x, dim, mask) result(res)
      ${t1}$, intent(in) :: x(:, :)
      integer, intent(in) :: dim
      logical, intent(in), optional :: mask
      ${t1}$ :: res(merge(size(x, 1), size(x, 2), mask = 1<dim)&
                          , merge(size(x, 1), size(x, 2), mask = 1<dim))

      integer :: i, j
      ${t1}$ :: mean_(merge(size(x, 1), size(x, 2), mask = 1<dim))
      ${t1}$ :: center(size(x, 1),size(x, 2))

      if (.not.optval(mask, .true.) .or. size(x) < 2) then
        res = ieee_value(1._${k1}$, ieee_quiet_nan)
        return
      end if

      mean_ = mean(x, dim)
      select case(dim)
        case(1)
          do i = 1, size(x, 1)
            center(i, :) = x(i, :) - mean_
          end do
          #:if t1[0] == 'r'
            res = matmul( transpose(center), center)
          #:else
            res = matmul( transpose(conjg(center)), center)
          #:endif
        case(2)
          do i = 1, size(x, 2)
            center(:, i) = x(:, i) - mean_
          end do
          #:if t1[0] == 'r'
            res = matmul( center, transpose(center))
          #:else
            res = matmul( center, transpose(conjg(center)))
          #:endif
        case default
          call error_stop("ERROR (corr): wrong dimension")
      end select

      mean_ = 1 / sqrt(diag(res))
      do i = 1, size(res, 1)
        do j = 1, size(res, 2)
          res(j, i) = res(j, i) * mean_(i) * mean_(j)
        end do
      end do

    end function ${RName}$
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:set RName = rname("corr",2, t1, k1, 'dp')
    function ${RName}$(x, dim, mask) result(res)
      ${t1}$, intent(in) :: x(:, :)
      integer, intent(in) :: dim
      logical, intent(in), optional :: mask
      real(dp) :: res(merge(size(x, 1), size(x, 2), mask = 1<dim)&
                      , merge(size(x, 1), size(x, 2), mask = 1<dim))

      integer :: i, j
      real(dp) :: mean_(merge(size(x, 1), size(x, 2), mask = 1<dim))
      real(dp) :: center(size(x, 1),size(x, 2))

      if (.not.optval(mask, .true.) .or. size(x) < 2) then
        res = ieee_value(1._dp, ieee_quiet_nan)
        return
      end if

      mean_ = mean(x, dim)
      select case(dim)
        case(1)
          do i = 1, size(x, 1)
            center(i, :) = real(x(i, :), dp) - mean_
          end do
          res = matmul( transpose(center), center)
        case(2)
          do i = 1, size(x, 2)
            center(:, i) = real(x(:, i), dp) - mean_
          end do
          res = matmul( center, transpose(center))
        case default
          call error_stop("ERROR (corr): wrong dimension")
      end select

      mean_ = 1 / sqrt(diag(res))
      do i = 1, size(res, 1)
        do j = 1, size(res, 2)
          res(j, i) = res(j, i) * mean_(i) * mean_(j)
        end do
      end do

    end function ${RName}$
  #:endfor


  #:for k1, t1 in RC_KINDS_TYPES
    #:set RName = rname("corr_mask",2, t1, k1)
    function ${RName}$(x, dim, mask) result(res)
      ${t1}$, intent(in) :: x(:, :)
      integer, intent(in) :: dim
      logical, intent(in) :: mask(:,:)
      ${t1}$ :: res(merge(size(x, 1), size(x, 2), mask = 1<dim)&
                          , merge(size(x, 1), size(x, 2), mask = 1<dim))

      integer :: i, j
      ${t1}$ :: centeri_(merge(size(x, 2), size(x, 1), mask = 1<dim))
      ${t1}$ :: centerj_(merge(size(x, 2), size(x, 1), mask = 1<dim))
      logical :: mask_(merge(size(x, 2), size(x, 1), mask = 1<dim))

      select case(dim)
        case(1)
          do i = 1, size(res, 2)
            do j = 1, size(res, 1)
             mask_ = merge(.true., .false., mask(:, i) .and. mask(:, j))
             centeri_ = merge( x(:, i) - mean(x(:, i), mask = mask_),&
              #:if t1[0] == 'r'
                0._${k1}$,&
              #:else
                cmplx(0,0,kind=${k1}$),&
              #:endif
                mask_)
             centerj_ = merge( x(:, j) - mean(x(:, j), mask = mask_),&
              #:if t1[0] == 'r'
                0._${k1}$,&
              #:else
                cmplx(0,0,kind=${k1}$),&
              #:endif
                mask_)

              res(j, i) = dot_product( centerj_, centeri_)&
               /sqrt(dot_product( centeri_, centeri_)*&
                     dot_product( centerj_, centerj_))

            end do
          end do
        case(2)
          do i = 1, size(res, 2)
            do j = 1, size(res, 1)
             mask_ = merge(.true., .false., mask(i, :) .and. mask(j, :))
             centeri_ = merge( x(i, :) - mean(x(i, :), mask = mask_),&
              #:if t1[0] == 'r'
                0._${k1}$,&
              #:else
                cmplx(0,0,kind=${k1}$),&
              #:endif
                mask_)
             centerj_ = merge( x(j, :) - mean(x(j, :), mask = mask_),&
              #:if t1[0] == 'r'
                0._${k1}$,&
              #:else
                cmplx(0,0,kind=${k1}$),&
              #:endif
                mask_)

              res(j, i) = dot_product( centeri_, centerj_)&
               /sqrt(dot_product( centeri_, centeri_)*&
                     dot_product( centerj_, centerj_))
            end do
          end do
        case default
          call error_stop("ERROR (corr): wrong dimension")
      end select

    end function ${RName}$
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:set RName = rname("corr_mask",2, t1, k1, 'dp')
    function ${RName}$(x, dim, mask) result(res)
      ${t1}$, intent(in) :: x(:, :)
      integer, intent(in) :: dim
      logical, intent(in) :: mask(:,:)
      real(dp) :: res(merge(size(x, 1), size(x, 2), mask = 1<dim)&
                          , merge(size(x, 1), size(x, 2), mask = 1<dim))

      integer :: i, j
      real(dp) :: centeri_(merge(size(x, 2), size(x, 1), mask = 1<dim))
      real(dp) :: centerj_(merge(size(x, 2), size(x, 1), mask = 1<dim))
      logical :: mask_(merge(size(x, 2), size(x, 1), mask = 1<dim))

      select case(dim)
        case(1)
          do i = 1, size(res, 2)
            do j = 1, size(res, 1)
             mask_ = merge(.true., .false., mask(:, i) .and. mask(:, j))
             centeri_ = merge( x(:, i) - mean(x(:, i), mask = mask_),&
                0._dp, mask_)
             centerj_ = merge( x(:, j) - mean(x(:, j), mask = mask_),&
                0._dp, mask_)

             res(j, i) = dot_product( centerj_, centeri_)&
                 /sqrt(dot_product( centeri_, centeri_)*&
                       dot_product( centerj_, centerj_))

            end do
          end do
        case(2)
          do i = 1, size(res, 2)
            do j = 1, size(res, 1)
             mask_ = merge(.true., .false., mask(i, :) .and. mask(j, :))
             centeri_ = merge( x(i, :) - mean(x(i, :), mask = mask_),&
                0._dp, mask_)
             centerj_ = merge( x(j, :) - mean(x(j, :), mask = mask_),&
                0._dp, mask_)

             res(j, i) = dot_product( centeri_, centerj_)&
                 /sqrt(dot_product( centeri_, centeri_)*&
                       dot_product( centerj_, centerj_))
            end do
          end do
        case default
          call error_stop("ERROR (corr): wrong dimension")
      end select

    end function ${RName}$
  #:endfor



  #:for k1, t1 in RC_KINDS_TYPES
    #:set RName = rname("cov",1, t1, k1)
    module function ${RName}$(x, dim, mask, corrected) result(res)
      ${t1}$, intent(in) :: x(:)
      integer, intent(in) :: dim
      logical, intent(in), optional :: mask
      logical, intent(in), optional :: corrected
      real(${k1}$) :: res

      if (.not.optval(mask, .true.)) then
        res = ieee_value(1._${k1}$, ieee_quiet_nan)
        return
      end if

      res = var(x, dim, corrected = optval(corrected, .true.))

    end function ${RName}$
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:set RName = rname("cov",1, t1, k1, 'dp')
    module function ${RName}$(x, dim, mask, corrected) result(res)
      ${t1}$, intent(in) :: x(:)
      integer, intent(in) :: dim
      logical, intent(in), optional :: mask
      logical, intent(in), optional :: corrected
      real(dp) :: res

      if (.not.optval(mask, .true.)) then
        res = ieee_value(1._dp, ieee_quiet_nan)
        return
      end if

      res = var(x, dim, corrected = optval(corrected, .true.))

    end function ${RName}$
  #:endfor


  #:for k1, t1 in RC_KINDS_TYPES
    #:set RName = rname("cov_mask",1, t1, k1)
    module function ${RName}$(x, dim, mask, corrected) result(res)
      ${t1}$, intent(in) :: x(:)
      integer, intent(in) :: dim
      logical, intent(in) :: mask(:)
      logical, intent(in), optional :: corrected
      real(${k1}$) :: res

      res = var(x, dim, mask, corrected = optval(corrected, .true.))

    end function ${RName}$
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:set RName = rname("cov_mask",1, t1, k1, 'dp')
    module function ${RName}$(x, dim, mask, corrected) result(res)
      ${t1}$, intent(in) :: x(:)
      integer, intent(in) :: dim
      logical, intent(in) :: mask(:)
      logical, intent(in), optional :: corrected
      real(dp) :: res

      res = var(x, dim, mask, corrected = optval(corrected, .true.))

    end function ${RName}$
  #:endfor


  #:for k1, t1 in RC_KINDS_TYPES
    #:set RName = rname("cov",2, t1, k1)
    module function ${RName}$(x, dim, mask, corrected) result(res)
      ${t1}$, intent(in) :: x(:, :)
      integer, intent(in) :: dim
      logical, intent(in), optional :: mask
      logical, intent(in), optional :: corrected
      ${t1}$ :: res(merge(size(x, 1), size(x, 2), mask = 1<dim)&
                          , merge(size(x, 1), size(x, 2), mask = 1<dim))

      integer :: i
      ${t1}$ :: mean_(merge(size(x, 1), size(x, 2), mask = 1<dim))
      ${t1}$ :: center(size(x, 1),size(x, 2))

      if (.not.optval(mask, .true.)) then
        res = ieee_value(1._${k1}$, ieee_quiet_nan)
        return
      end if

      mean_ = mean(x, dim)
      select case(dim)
        case(1)
          do i = 1, size(x, 1)
            center(i, :) = x(i, :) - mean_
          end do
          #:if t1[0] == 'r'
            res = matmul( transpose(center), center)
          #:else
            res = matmul( transpose(conjg(center)), center)
          #:endif
        case(2)
          do i = 1, size(x, 2)
            center(:, i) = x(:, i) - mean_
          end do
          #:if t1[0] == 'r'
            res = matmul( center, transpose(center))
          #:else
            res = matmul( center, transpose(conjg(center)))
          #:endif
        case default
          call error_stop("ERROR (cov): wrong dimension")
      end select
      res = res / (size(x, dim) - merge(1, 0, optval(corrected, .true.)))

    end function ${RName}$
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:set RName = rname("cov",2, t1, k1, 'dp')
    module function ${RName}$(x, dim, mask, corrected) result(res)
      ${t1}$, intent(in) :: x(:, :)
      integer, intent(in) :: dim
      logical, intent(in), optional :: mask
      logical, intent(in), optional :: corrected
      real(dp) :: res(merge(size(x, 1), size(x, 2), mask = 1<dim)&
                      , merge(size(x, 1), size(x, 2), mask = 1<dim))

      integer :: i
      real(dp) :: mean_(merge(size(x, 1), size(x, 2), mask = 1<dim))
      real(dp) :: center(size(x, 1),size(x, 2))

      if (.not.optval(mask, .true.)) then
        res = ieee_value(1._dp, ieee_quiet_nan)
        return
      end if

      mean_ = mean(x, dim)
      select case(dim)
        case(1)
          do i = 1, size(x, 1)
            center(i, :) = real(x(i, :), dp) - mean_
          end do
          res = matmul( transpose(center), center)
        case(2)
          do i = 1, size(x, 2)
            center(:, i) = real(x(:, i), dp) - mean_
          end do
          res = matmul( center, transpose(center))
        case default
          call error_stop("ERROR (cov): wrong dimension")
      end select
      res = res / (size(x, dim) - merge(1, 0, optval(corrected, .true.)))

    end function ${RName}$
  #:endfor


  #:for k1, t1 in RC_KINDS_TYPES
    #:set RName = rname("cov_mask",2, t1, k1)
    module function ${RName}$(x, dim, mask, corrected) result(res)
      ${t1}$, intent(in) :: x(:, :)
      integer, intent(in) :: dim
      logical, intent(in) :: mask(:,:)
      logical, intent(in), optional :: corrected
      ${t1}$ :: res(merge(size(x, 1), size(x, 2), mask = 1<dim)&
                          , merge(size(x, 1), size(x, 2), mask = 1<dim))

      integer :: i, j, n
      ${t1}$ :: centeri_(merge(size(x, 2), size(x, 1), mask = 1<dim))
      ${t1}$ :: centerj_(merge(size(x, 2), size(x, 1), mask = 1<dim))
      logical :: mask_(merge(size(x, 2), size(x, 1), mask = 1<dim))

      select case(dim)
        case(1)
          do i = 1, size(res, 2)
            do j = 1, size(res, 1)
             mask_ = merge(.true., .false., mask(:, i) .and. mask(:, j))
             centeri_ = merge( x(:, i) - mean(x(:, i), mask = mask_),&
              #:if t1[0] == 'r'
                0._${k1}$,&
              #:else
                cmplx(0,0,kind=${k1}$),&
              #:endif
                mask_)
             centerj_ = merge( x(:, j) - mean(x(:, j), mask = mask_),&
              #:if t1[0] == 'r'
                0._${k1}$,&
              #:else
                cmplx(0,0,kind=${k1}$),&
              #:endif
                mask_)

              n = count(mask_)
              res(j, i) = dot_product( centerj_, centeri_)&
                           / (n - merge(1, 0,&
                            optval(corrected, .true.) .and. n > 0))
            end do
          end do
        case(2)
          do i = 1, size(res, 2)
            do j = 1, size(res, 1)
             mask_ = merge(.true., .false., mask(i, :) .and. mask(j, :))
             centeri_ = merge( x(i, :) - mean(x(i, :), mask = mask_),&
              #:if t1[0] == 'r'
                0._${k1}$,&
              #:else
                cmplx(0,0,kind=${k1}$),&
              #:endif
                mask_)
             centerj_ = merge( x(j, :) - mean(x(j, :), mask = mask_),&
              #:if t1[0] == 'r'
                0._${k1}$,&
              #:else
                cmplx(0,0,kind=${k1}$),&
              #:endif
                mask_)

              n = count(mask_)
              res(j, i) = dot_product( centeri_, centerj_)&
                           / (n - merge(1, 0,&
                            optval(corrected, .true.) .and. n > 0))
            end do
          end do
        case default
          call error_stop("ERROR (cov): wrong dimension")
      end select

    end function ${RName}$
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:set RName = rname("cov_mask",2, t1, k1, 'dp')
    module function ${RName}$(x, dim, mask, corrected) result(res)
      ${t1}$, intent(in) :: x(:, :)
      integer, intent(in) :: dim
      logical, intent(in) :: mask(:,:)
      logical, intent(in), optional :: corrected
      real(dp) :: res(merge(size(x, 1), size(x, 2), mask = 1<dim)&
                          , merge(size(x, 1), size(x, 2), mask = 1<dim))

      integer :: i, j, n
      real(dp) :: centeri_(merge(size(x, 2), size(x, 1), mask = 1<dim))
      real(dp) :: centerj_(merge(size(x, 2), size(x, 1), mask = 1<dim))
      logical :: mask_(merge(size(x, 2), size(x, 1), mask = 1<dim))

      select case(dim)
        case(1)
          do i = 1, size(res, 2)
            do j = 1, size(res, 1)
              mask_ = merge(.true., .false., mask(:, i) .and. mask(:, j))
              centeri_ = merge( x(:, i) - mean(x(:, i), mask = mask_),&
                 0._dp, mask_)
              centerj_ = merge( x(:, j) - mean(x(:, j), mask = mask_),&
                 0._dp, mask_)

              n = count(mask_)
              res(j, i) = dot_product( centerj_, centeri_)&
                           / (n - merge(1, 0,&
                            optval(corrected, .true.) .and. n > 0))
            end do
          end do
        case(2)
          do i = 1, size(res, 2)
            do j = 1, size(res, 1)
              mask_ = merge(.true., .false., mask(i, :) .and. mask(j, :))
              centeri_ = merge( x(i, :) - mean(x(i, :), mask = mask_),&
                 0._dp, mask_)
              centerj_ = merge( x(j, :) - mean(x(j, :), mask = mask_),&
                 0._dp, mask_)

              n = count(mask_)
              res(j, i) = dot_product( centeri_, centerj_)&
                           / (n - merge(1, 0,&
                            optval(corrected, .true.) .and. n > 0))
            end do
          end do
        case default
          call error_stop("ERROR (cov): wrong dimension")
      end select

    end function ${RName}$
  #:endfor


  #:for k1, t1 in RC_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname("mean_all",rank, t1, k1)
      module function ${RName}$ (x, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        logical, intent(in), optional :: mask
        ${t1}$ :: res

        if (.not.optval(mask, .true.)) then
          res = ieee_value(1._${k1}$, ieee_quiet_nan)
          return
        end if

        res = sum(x) / real(size(x, kind = int64), ${k1}$)

      end function ${RName}$
    #:endfor
  #:endfor

  #:for k1, t1 in INT_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname('mean_all', rank, t1, k1,'dp')
      module function ${RName}$(x, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        logical, intent(in), optional :: mask
        real(dp) :: res

        if (.not.optval(mask, .true.)) then
          res = ieee_value(1._dp, ieee_quiet_nan)
          return
        end if

        res = sum(real(x, dp)) / real(size(x, kind = int64), dp)

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in RC_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname("mean",rank, t1, k1)
      module function ${RName}$(x, dim, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: dim
        logical, intent(in), optional :: mask
        ${t1}$ :: res${reduced_shape('x', rank, 'dim')}$

        if (.not.optval(mask, .true.)) then
          res = ieee_value(1._${k1}$, ieee_quiet_nan)
          return
        end if

        if (dim >= 1 .and. dim <= ${rank}$) then
          res = sum(x, dim) / real(size(x, dim), ${k1}$)
        else
          call error_stop("ERROR (mean): wrong dimension")
        end if

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname("mean",rank, t1, k1,'dp')
      module function ${RName}$(x, dim, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: dim
        logical, intent(in), optional :: mask
        real(dp) :: res${reduced_shape('x', rank, 'dim')}$

        if (.not.optval(mask, .true.)) then
          res = ieee_value(1._dp, ieee_quiet_nan)
          return
        end if

        if (dim >= 1 .and. dim <= ${rank}$) then
          res = sum(real(x, dp), dim) / real(size(x, dim), dp)
        else
          call error_stop("ERROR (mean): wrong dimension")
        end if

      end function ${RName}$
    #:endfor
  #:endfor

  #:for k1, t1 in RC_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname('mean_mask_all',rank, t1, k1)
      module function ${RName}$(x, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        logical, intent(in) :: mask${ranksuffix(rank)}$
        ${t1}$ :: res

        res = sum(x, mask) / real(count(mask, kind = int64), ${k1}$)

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname('mean_mask_all',rank, t1, k1, 'dp')
      module function ${RName}$(x, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        logical, intent(in) :: mask${ranksuffix(rank)}$
        real(dp) :: res

        res = sum(real(x, dp), mask) / real(count(mask, kind = int64), dp)

      end function ${RName}$
    #:endfor
  #:endfor

  #:for k1, t1 in RC_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname('mean_mask',rank, t1, k1)
      module function  ${RName}$(x, dim, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: dim
        logical, intent(in) :: mask${ranksuffix(rank)}$
        ${t1}$ :: res${reduced_shape('x', rank, 'dim')}$

        if (dim >= 1 .and. dim <= ${rank}$) then
          res = sum(x, dim, mask) / real(count(mask, dim), ${k1}$)
        else
          call error_stop("ERROR (mean): wrong dimension")
        end if

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname('mean_mask',rank, t1, k1, 'dp')
      module function ${RName}$(x, dim, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: dim
        logical, intent(in) :: mask${ranksuffix(rank)}$
        real(dp) :: res${reduced_shape('x', rank, 'dim')}$

        if (dim >= 1 .and. dim <= ${rank}$) then
          res = sum(real(x, dp), dim, mask) / real(count(mask, dim), dp)
        else
          call error_stop("ERROR (mean): wrong dimension")
        end if

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in RC_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname("var_all",rank, t1, k1)
      module function ${RName}$(x, mask, corrected) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        logical, intent(in), optional :: mask
        logical, intent(in), optional :: corrected
        real(${k1}$) :: res

        real(${k1}$) :: n
        ${t1}$ :: mean

        if (.not.optval(mask, .true.)) then
          res = ieee_value(1._${k1}$, ieee_quiet_nan)
          return
        end if

        n = real(size(x, kind = int64), ${k1}$)
        mean = sum(x) / n

        #:if t1[0] == 'r'
          res = sum((x - mean)**2) / (n - merge(1, 0 , optval(corrected, .true.)))
        #:else
          res = sum(abs(x - mean)**2) / (n - merge(1, 0, optval(corrected, .true.)))
        #:endif

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname("var_all",rank, t1, k1, 'dp')
      module function ${RName}$(x, mask, corrected) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        logical, intent(in), optional :: mask
        logical, intent(in), optional :: corrected
        real(dp) :: res

        real(dp) :: n, mean

        if (.not.optval(mask, .true.)) then
          res = ieee_value(1._dp, ieee_quiet_nan)
          return
        end if

        n = real(size(x, kind = int64), dp)
        mean = sum(real(x, dp)) / n

        res = sum((real(x, dp) - mean)**2) / (n - merge(1, 0, optval(corrected, .true.)))

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in RC_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname("var",rank, t1, k1)
      module function ${RName}$(x, dim, mask, corrected) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: dim
        logical, intent(in), optional :: mask
        logical, intent(in), optional :: corrected
        real(${k1}$) :: res${reduced_shape('x', rank, 'dim')}$

        integer :: i
        real(${k1}$) :: n
        ${t1}$ :: mean${reduced_shape('x', rank, 'dim')}$

        if (.not.optval(mask, .true.)) then
          res = ieee_value(1._${k1}$, ieee_quiet_nan)
          return
        end if

        res = 0._${k1}$
        select case(dim)
          #:for fi in range(1, rank+1)
          case(${fi}$)
            n = size(x, dim)
            mean = sum(x, dim) / n
            do i = 1, size(x, dim)
              #:if t1[0] == 'r'
                res = res + (x${select_subarray(rank, [(fi, 'i')])}$ - mean)**2
              #:else
                res = res + abs(x${select_subarray(rank, [(fi, 'i')])}$ - mean)**2
              #:endif
            end do
          #:endfor
          case default
            call error_stop("ERROR (var): wrong dimension")
        end select
        res = res / (n - merge(1, 0, optval(corrected, .true.)))

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname("var",rank, t1, k1, 'dp')
      module function ${RName}$(x, dim, mask, corrected) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: dim
        logical, intent(in), optional :: mask
        logical, intent(in), optional :: corrected
        real(dp) :: res${reduced_shape('x', rank, 'dim')}$

        integer :: i
        real(dp) :: n
        real(dp) :: mean${reduced_shape('x', rank, 'dim')}$

        if (.not.optval(mask, .true.)) then
          res = ieee_value(1._dp, ieee_quiet_nan)
          return
        end if

        res = 0._dp
        select case(dim)
          #:for fi in range(1, rank+1)
          case(${fi}$)
            n = size(x, dim)
            mean = sum(real(x, dp), dim) / n
            do i = 1, size(x, dim)
              res = res + (real(x${select_subarray(rank, [(fi, 'i')])}$, dp) - mean)**2
            end do
          #:endfor
          case default
            call error_stop("ERROR (var): wrong dimension")
        end select
        res = res / (n - merge(1, 0, optval(corrected, .true.)))

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in RC_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname("var_mask_all",rank, t1, k1)
      module function ${RName}$(x, mask, corrected) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        logical, intent(in) :: mask${ranksuffix(rank)}$
        logical, intent(in), optional :: corrected
        real(${k1}$) :: res

        real(${k1}$) :: n
        ${t1}$ :: mean

        n = real(count(mask, kind = int64), ${k1}$)
        mean = sum(x, mask) / n

        #:if t1[0] == 'r'
          res = sum((x - mean)**2, mask) / (n -&
        #:else
          res = sum(abs(x - mean)**2, mask) / (n -&
        #:endif
                merge(1, 0, (optval(corrected, .true.) .and. n > 0)))

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname("var_mask_all",rank, t1, k1, 'dp')
      module function ${RName}$(x, mask, corrected) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        logical, intent(in) :: mask${ranksuffix(rank)}$
        logical, intent(in), optional :: corrected
        real(dp) :: res

        real(dp) :: n, mean

        n = real(count(mask, kind = int64), dp)
        mean = sum(real(x, dp), mask) / n

        res = sum((real(x, dp) - mean)**2, mask) / (n -&
              merge(1, 0, (optval(corrected, .true.) .and. n > 0)))

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in RC_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname("var_mask",rank, t1, k1)
      module function ${RName}$(x, dim, mask, corrected) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: dim
        logical, intent(in) :: mask${ranksuffix(rank)}$
        logical, intent(in), optional :: corrected
        real(${k1}$) :: res${reduced_shape('x', rank, 'dim')}$

        integer :: i
        real(${k1}$) :: n${reduced_shape('x', rank, 'dim')}$
        ${t1}$ :: mean${reduced_shape('x', rank, 'dim')}$

        res = 0._${k1}$
        select case(dim)
          #:for fi in range(1, rank+1)
          case(${fi}$)
            n = count(mask, dim)
            mean = sum(x, dim, mask) / n
            do i = 1, size(x, dim)
              #:if t1[0] == 'r'
                res = res + merge( (x${select_subarray(rank, [(fi, 'i')])}$ - mean)**2,&
              #:else
                res = res + merge( abs(x${select_subarray(rank, [(fi, 'i')])}$ - mean)**2,&
              #:endif
                                  0._${k1}$,&
                                  mask${select_subarray(rank, [(fi, 'i')])}$)
            end do
          #:endfor
          case default
            call error_stop("ERROR (var): wrong dimension")
        end select
        res = res / (n - merge(1, 0, (optval(corrected, .true.) .and. n > 0)))

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:for rank in RANKS
      #:set RName = rname("var_mask",rank, t1, k1, 'dp')
      module function ${RName}$(x, dim, mask, corrected) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: dim
        logical, intent(in) :: mask${ranksuffix(rank)}$
        logical, intent(in), optional :: corrected
        real(dp) :: res${reduced_shape('x', rank, 'dim')}$

        integer :: i
        real(dp) :: n${reduced_shape('x', rank, 'dim')}$
        real(dp) :: mean${reduced_shape('x', rank, 'dim')}$

        res = 0._dp
        select case(dim)
          #:for fi in range(1, rank+1)
          case(${fi}$)
            n = count(mask, dim)
            mean = sum(real(x, dp), dim, mask) / n
            do i = 1, size(x, dim)
              res = res + merge((real(x${select_subarray(rank, [(fi, 'i')])}$, dp) - mean)**2,&
                                  0._dp, mask${select_subarray(rank, [(fi, 'i')])}$)
            end do
          #:endfor
          case default
            call error_stop("ERROR (var): wrong dimension")
        end select
        res = res / (n - merge(1, 0, (optval(corrected, .true.) .and. n > 0)))

      end function ${RName}$
    #:endfor
  #:endfor

end module stdlib_stats
