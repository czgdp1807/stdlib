#:include "common.fypp"
#:set RANKS = range(1, MAXRANK + 1)
#:set REDRANKS = range(2, MAXRANK + 1)
#:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES
module stdlib_stats_moment_scalar

  use, intrinsic:: ieee_arithmetic, only: ieee_value, ieee_quiet_nan
  use stdlib_error, only: error_stop
  use stdlib_optval, only: optval
  use stdlib_kinds, only: sp, dp, xdp, qp, &
      int8, int16, int32, int64
  implicit none

  interface moment
    !! version: experimental
    !!
    !! Central moment of array elements
    !! ([Specification](../page/specs/stdlib_stats.html#moment-central-moments-of-array-elements))

    #:for k1, t1 in RC_KINDS_TYPES
      #:for rank in REDRANKS
        #:set RName = rname("moment_scalar",rank, t1, k1)
        procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:for rank in REDRANKS
        #:set RName = rname("moment_scalar",rank, t1, k1, 'dp')
        procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in RC_KINDS_TYPES
      #:for rank in REDRANKS
        #:set RName = rname("moment_mask_scalar",rank, t1, k1)
        procedure :: ${RName}$
      #:endfor
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
      #:for rank in REDRANKS
        #:set RName = rname("moment_mask_scalar",rank, t1, k1, 'dp')
        procedure :: ${RName}$
      #:endfor
    #:endfor

  end interface
contains

  pure function my_merge(val1, val2, mask) result(merged_value)
    integer, intent(in) :: val1, val2
    logical, intent(in) :: mask
    integer :: merged_value

    if (mask) then
      merged_value = val1
    else
      merged_value = val2
    end if

  end function my_merge

  #:for k1, t1 in RC_KINDS_TYPES
    #:for rank in REDRANKS
      #:set RName = rname("moment_scalar",rank, t1, k1)
      module function ${RName}$(x, order, dim, center, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: order
        integer, intent(in) :: dim
        ${t1}$, intent(in) :: center
        logical, intent(in), optional :: mask
        ${t1}$ :: res${reduced_shape('x', rank, 'dim')}$
        ${t1}$ :: temp${arraysuffix(rank)}$


        if (.not.optval(mask, .true.)) then
          res = ieee_value(1._${k1}$, ieee_quiet_nan)
          return
        end if

        if (dim >= 1 .and. dim <= ${rank}$) then
          temp = (x - center)
          temp = temp**order
          res = sum(temp, dim)
          res = res / size(x, dim)
        else
          call error_stop("ERROR (moment): wrong dimension")
        end if

      end function ${RName}$
    #:endfor
  #:endfor

  #:for k1, t1 in INT_KINDS_TYPES
    #:for rank in REDRANKS
      #:set RName = rname("moment_scalar",rank, t1, k1, 'dp')
      module function ${RName}$(x, order, dim, center, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: order
        integer, intent(in) :: dim
        real(dp),intent(in) :: center
        logical, intent(in), optional :: mask
        real(dp) :: res${reduced_shape('x', rank, 'dim')}$
        ${t1}$ :: temp${arraysuffix(rank)}$

        if (.not.optval(mask, .true.)) then
          res = ieee_value(1._dp, ieee_quiet_nan)
          return
        end if

        if (dim >= 1 .and. dim <= ${rank}$) then
          temp = real(x, dp)
          temp = temp - center
          temp = temp**order
          res = sum( temp, dim)
          res = res / size(x, dim)
        else
          call error_stop("ERROR (moment): wrong dimension")
        end if

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in RC_KINDS_TYPES
    #:for rank in REDRANKS
      #:set RName = rname("moment_mask_scalar",rank, t1, k1)
      module function ${RName}$(x, order, dim, center, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: order
        integer, intent(in) :: dim
        ${t1}$, intent(in) :: center
        logical, intent(in) :: mask${ranksuffix(rank)}$
        ${t1}$ :: res${reduced_shape('x', rank, 'dim')}$
        ${t1}$ :: temp${arraysuffix(rank)}$

        if (dim >= 1 .and. dim <= ${rank}$) then
          temp = (x - center)
          temp = temp**order
          #:for n_ in range(1, rank+1)
            if (dim == ${n_}$) res = sum(temp, dim, mask) / count(mask, ${n_}$)
          #:endfor
        else
          call error_stop("ERROR (moment): wrong dimension")
        end if

      end function ${RName}$
    #:endfor
  #:endfor


  #:for k1, t1 in INT_KINDS_TYPES
    #:for rank in REDRANKS
      #:set RName = rname("moment_mask_scalar",rank, t1, k1, 'dp')
      module function ${RName}$(x, order, dim, center, mask) result(res)
        ${t1}$, intent(in) :: x${ranksuffix(rank)}$
        integer, intent(in) :: order
        integer, intent(in) :: dim
        real(dp), intent(in) :: center
        logical, intent(in) :: mask${ranksuffix(rank)}$
        real(dp) :: res${reduced_shape('x', rank, 'dim')}$
        ${t1}$ :: temp${arraysuffix(rank)}$

        if (dim >= 1 .and. dim <= ${rank}$) then
          temp = (real(x, dp) - center)
          temp = temp**order
          #:for n_ in range(1, rank+1)
            if (dim == ${n_}$) res = sum(temp, dim, mask) / real(count(mask, ${n_}$), dp)
          #:endfor
        else
          call error_stop("ERROR (moment): wrong dimension")
        end if

      end function ${RName}$
    #:endfor
  #:endfor

end module
